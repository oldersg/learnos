## 内存管理系统
### makefile基本知识
linux中有atime，mtime，ctime使用`stat filename`  
makefile通过mtime（**只改变数据**）的方式来更新  
```make
1:2
	echo "hello makefile"
```
在依次创建了1和2文件后，会输出echo "hello makefile"  
使用@符号取消命令行输出，可见**test1文件夹**  

---
### 伪指令
使用`.PHONY:clean`用法添加伪指令  
常见的伪指令用法如下：
| 名称  | 功能  |
|---|---|
| all  | 完成模块所有打包  |
| test  | 测试makefile流程  |
|  clean | 搭配rm使用  |

---
### 变量
定义变量：`obj = test1.o test2.o`  
使用：`$(obj)`  
可见**test2文件夹**  
系统变量使用  
命令相关
| 名称  | 功能  |
|---|---|
| CC  | C语言编译器，默认为"cc"  |
| CXX  | C++编译参数，默认为"g++"  |
|  CPP | C预处理器，默认为"$(CC) -E"  |

参数相关
| 名称  | 功能  |
|---|---|
| CFLAGS  | C语言编译参数  |
| CXXFLAGS  | C++编译参数  |
|  CPPFLAGS | C预处理器参数  |
|  LDFLAGS | 链接器参数  |

---

### 隐式规则
注释：`#`  
换行：`\`  
有时不需要添加固定的命令依然能生成目标文件

---

### 神奇的用法
| 名称  | 功能  |
|---|---|
| $@  | 目标文件的集合  |
| $<  | 依赖文件的第一个  |
|  $^ | 所有依赖文件  |
|  $? | 所有比目标文件mtime更加新的依赖文件集合  |
可见**test3**

### 实现assert
assert触发后，要在关中断的情况下实现  
见代码**001/kernel/interrupt.c**  
代码实现了开关中断，使用`sti`进行开中断，`cli`关中断  
见代码**001/kernel/debug.***  
gcc–D宏可以用来定义某个宏是否使用  
makefile文件中变量解释：

+ `-Wall`参数用于开启所有的警告信息
+ `-fno-builtin`表示不使用C的内置函数，以防冲突
+ `-Wstrict-prototypes`选项要求函数声明中必须有参数类型，否则编译时发出警告
+ `-Wmissing-prototypes` 选项要求函数必须有声明，否则编译时发出警告
+ `-fno-stack-protector` 禁用堆栈保护

对于链接阶段最好不要用模式匹配，因为无法保证链接顺序，最好是调用在前，实现在后

### 字符串操作函数
同C类似，见代码**002**

---

### bitmap实现
见代码**003**  
主要有初始化bitmap，判断某位bit的值，在位图中申请连续cnt个位和修改某位bit的值  

---

### 实现内存管理
见代码**004**  
物理内存池：将物理内存池分为用户进程的内存池和操作系统的内存池，两者各占一半  
虚拟内存池：每个任务都有独立的虚拟地址空间  
用户进程申请内存时，OS先从用户进程自己的虚拟地址池中分配空闲虚拟地址，然后再从用户物理内存池中分配空闲的物理内存，最后将两者建立映射关系。  
内存位图的基址为0xc009a00的原因

+ 将来实现的PCB占1页内存，PCB地址假设为0xXXXXX000，该地址以上存储进程的PCB信息，在该页最高处0xXXXXXfff以下存储0特权级下使用的栈。由于esp先自减，再存储，所以栈顶指向0xXXXXXfff+1，为下一个页的起始。  
+ 再load.S中将内核栈顶指向了0xc009f000，那么PCB起始为0xc009e000，此时的0x9f000是在低端1MB的最高地址。  
+ 4页位图能管理512MB内存（提前设置好），用0xc0009e000-0x4000刚好是0xc009a000，所以内存位图的基址为0xc009a00

把位图放在0xc009a00处还因为此地址位于低端 1MB 之内，这里面的内存几乎都被占用了，所以不用再管理了
0xc0100000～0xc0101fff是页表和页目录的虚拟地址，已经提前在loader.S中定义好了，无法使用  
虚拟内存池紧挨着物理内存池后面

---
### 实现内存分配
见代码**005**  
pte_ptr函数原理：使用新的虚拟地址来访问页表项的物理地址

1. 先访问页目录表，由于第1023个存储的是页目录表的物理地址，但处理器会将它当成页表物理地址处理，从而得到新的虚拟地址的高10位。
2. 寻找页表。将原来的虚拟地址的高10位取出当成新的虚拟地址的中间10位
3. 将原来的虚拟地址的中间10位取出，并乘4，当成新的虚拟地址的低12位
4. 此时的新的虚拟地址指向原来虚拟地址的pte

pde_ptr函数原理同理

1. 0xfffffxxx时就会访问两次最后的目录项，还是回到了目录表中。
2. 最后将原来的虚拟地址*4，当成新的虚拟地址的低12位就可以得到pde

前两个函数计算出 当前虚拟地址：vaddr 对应的pte及pde的虚拟地址



